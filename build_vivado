#==============================================================================
# This looks up the Vivado version number that was used to create the project
# and ensures that the same version is used to process it here
#==============================================================================
get_vivado()
{
   version=
   grep 2024.2 $1 >/dev/null && version=2024.2
   grep 2021.1 $1 >/dev/null && version=2021.1
   if [ -z $version ]; then
       echo "Unable to determine Vivado version for $project"
       exit 1
   fi
   new=$(echo $VIVADO | sed "s/Vivado\/20[0-9][0-9]\.[0-9]/Vivado\/${version}/g")

   # Extract the first token of $VIVADO and display it
   read new _ <<<$new
   echo $new
}
#==========================================================================


#==================================================================
# This function will find "git_hash.vh" in the current directory
# tree, and silently update it to contain the git-hash of the
# most recent commit, formatted as a Verilog "localparam".
#
# This function will not affect the "last-modified" date of the
# "git_hash.vh" file, so the Vivado IPI won't erroneously complain
# that we have updated a module.
#
# Function options:
#  --dir <working_directory_name>
#  --hash <string_of_hex>
#
# Doug Wolf wrote this
#==================================================================
update_githash_file()
{
    # We don't know what our hash is yet
    local hash=
    
    # We don't have a fully qualified path to our updateable file yet
    local fqp=

    # This is the basename of the file we're going to update
    local ofile=git_hash

    # Sit in a loop and parse the command line options
    while [ ! -z $1 ]; do

        # Did the caller hand us a hash on the command line?
        if [ "$1" == "--hash" ]; then
            hash=$2
            shift
            shift
            continue
        fi

        # Did the caller hand us a directory name on the command line?
        if [ "$1" == "--dir" ]; then
            local dir=$2
            if [ -z $dir ] || [ ! -d $dir ]; then 
                echo "$dir not found!" 1>&2
                return 3
            fi
            cd $dir
            shift
            shift
            continue
        fi

        # If we get here, the caller screwed up
        echo "Unknown option $1" 1>&2
        return 4

    done


    # If the current directory isn't a git repo, complain and quit
    if [ ! -d .git ]; then
        echo "$PWD is not a git repo!" 1>&2
        return 1
    fi

    # If the hash-file doesn't exist in the current directory, find it
    if [ -f ${ofile}.vh ]; then
        fqp=${ofile}.vh
    else
        fqp=$(find . | grep "/${ofile}\.vh$")
    fi

    # If we couldn't find a hash-file, complain
    if [ -z $fqp ]; then
        echo "${ofile}.vh not found under $PWD !" 1>&2
        return 2
    fi

    # If the caller didn't hand us a hash, find the git-hash of
    # the most recent commit
    if [ -z $hash ]; then
        hash=$(git log -1 --pretty=format:"%H")
    fi

    # Create a verilog header file with the git-hash
    echo "//"                                                 >new_hash.vh
    echo "// -- DO NOT EDIT! -- this file is auto-generated" >>new_hash.vh
    echo "//"                                                >>new_hash.vh
    echo "localparam[159:0] GIT_HASH = 160'h${hash};"        >>new_hash.vh

    # Copy our new hashfile into the project source, but *without* updating
    # the "last modified time" or any other meta-data.   This will prevent
    # Vivado from erroneously thinking that we've updated a module.
    cp -p new_hash.vh $fqp

    # And we don't need our temporary output file anymore
    rm -rf new_hash.vh
}
#==================================================================

#==================================================================
# This function removes every runme.log it finds
#==================================================================
remove_runme_logs()
{
    find . | grep "runme\.log$" >log_list
    while IFS= read line; do
            rm -rf $line
    done < log_list
    rm log_list
}
#==================================================================

      
#==================================================================
# Create the Vivado TCL build script
#
# $1 = The name of the project file
#==================================================================
create_build_script()
{
    local project_file=$1
    cat <<EOT >vivado_build.tcl
    open_project $(realpath $project_file)
    reset_project
    update_compile_order -fileset sources_1
    set_param general.maxThreads 32
    launch_runs impl_1 -to_step write_bitstream -jobs 32
EOT
}
#==================================================================


#==================================================================
# This displays each log file as they come into existence
#
# When this script returns, the file "build.result" will hold the
# string "pass" or "fail"
#==================================================================
show_logs()
{
    rm -rf build.result
    echo >logs_completed
    while true; do
        
        # Generate a list of "runme.log" log files
        find . | grep "runme\.log$" >log_list

        # Read the list, one line at a time
        while IFS= read logfile; do

            # Have we already completed reading this logfile?
            grep -q $logfile logs_completed
            
            # If we've already read this logfile, skip it
            test $? -eq 0 && continue;

            # Monitor this log file
            while true; do
                sleep 1
                cat $logfile
                grep -q "Exiting Vivado" $logfile
                test $? -eq 0 && break
            done
          
            
            # Record the fact that we've already read this logfile
            echo $logfile >>logs_completed
            
            # Does this logfile indicated a failure?
            grep "ERROR:" $logfile
            
            # If it does, record the result.  We're done
            if [ $? -eq 0 ]; then
                echo fail >build.result
                return 1
            fi
            
            # If this logfile is the implementation logfile, we're done
            echo $logfile | grep -q "impl_1/runme.log$"
            if [ $? -eq 0 ]; then
                echo pass >build.result
                return 0
            fi

        done < log_list
    done
}
#==================================================================

#==================================================================
# This displays the folder where the build artifacts will be stored
#
# This function expect a YYYYMMDD_HHMMSS timestamp to be passed in
#==================================================================
get_artifact_folder()
{  
    # Fetch the timestamp from the command line
    local timestamp=$1

    # If there is a 2nd option in the command line, it's project name
    local project_name=$2
    test -z "$project_name" && project_name=$(basename $PWD)

    # Fetch the short hash of the most recent git commit
    local hash=$(git log -1 --pretty=format:"%H" | cut -c1-8)

    # And display the directory where our build artifacts will go
    echo $VIVADO_BUILD_FOLDER/${project_name}/${timestamp}_${hash}
}
#==================================================================


#==================================================================
# This copies the build artifacts to the artifact folder
#==================================================================
copy_build_artifacts()
{
    # Find the name of the artifact folder
    dest=$1

    # If there is a 2nd parameter, its the project name
    local project_name=$2
    test -z "$project_name" && project_name=$(basename $PWD)

    # Create the folder for the artifacts
    mkdir -p $dest

    # Determine which of our three build artifacts exist
    bitfile=$(find ${project}.runs/impl_1 | grep  "\.bit$")
    binfile=$(find ${project}.runs/impl_1 | grep  "\.bin$")
    ltxfile=$(find ${project}.runs/impl_1 | grep  "\.ltx$")

    # Copy each build artifact to the destination directory
    test -z $bitfile || cp $bitfile $dest/${project_name}.bit
    test -z $binfile || cp $binfile $dest/${project_name}.bin
    test -z $ltxfile || cp $ltxfile $dest/${project_name}.ltx
}
#==================================================================


# Determine the name of the Vivado project file
project_file=$(ls *.xpr 2>/dev/null)

# Does the project file exist?
if [ -z "$project_file" ]; then
   echo "Not a Vivado project: $PWD"
   exit 1
fi

# Make sure this is a git repo
if [ ! -d .git ]; then
    echo "Not a git repo: $PWD" 1>&2
    exit 1
fi

# Make sure there's not already a build going for this project
output=$(ps aux | grep Vivado | grep $PWD)
if [ ! -z "$output" ]; then
    echo "There is already a build going for $PWD" 1>&2
    exit 1
fi

# Make sure that $VIVADO_BUILD_FOLDER is defined
if [ -z $VIVADO_BUILD_FOLDER ]; then
    echo "\$VIVADO_BUILD_FOLDER not defined!" 1>&2
    exit 1
fi

# Create the build script for this project
create_build_script $project_file

# Clean up existing Vivado log/journal cruft
rm -rf vivado*\.log vivado*\.jou

# Determine the executable path to the correct version of Vivado
VIVADO=$(get_vivado $project_file)

# Get the base name of the project (without file extension)
project="${project_file%.*}"

# Get rid of all the end products of any previous build
rm -rf ${project}.runs/impl_1/*

# Make sure the log files don't exist
remove_runme_logs

# This timestamp will be used to name the build artifact folder
# and will also be written into the bitstream file
timestamp=$(date +"%Y%m%d_%H%M%S")

# Make sure that git_hash.vh contains the hash from the current commit
update_githash_file

# Fetch the name of the folder where our build artifacts will be stored
artifact_folder=$(get_artifact_folder $timestamp)

# Kick off Vivado, which will run in the background
$VIVADO -mode batch -source vivado_build.tcl

# Show the output of the logfiles in real-time
show_logs

# Wait for Vivado to call it quits for this job
echo "Waiting for Vivado to exit..."
while true; do
   output=$(ps aux | grep Vivado | grep $PWD)
   test -z "$output" && break
   sleep 2
done

# If the build was successful, copy the artifacts
if [ $(cat build.result) == "pass" ]; then
    copy_build_artifacts $artifact_folder
    post_build="./post_build.sh"
    if [ -f $post_build ]; then
        chmod +x $post_build
        $post_build $artifact_folder
    fi
fi
